# 利用蒙特卡洛树算法实现的 Hex 棋程序

## 游戏规则与术语：

棋盘由11×11个六边形单元格组成，左上和右下两个边界线为蓝色，右上和左下两个边界线为红色，蓝色坐标表示范围0-10（在botzone图形界面中显示为A-K），红色坐标表示范围0-10（在botzone 图形界面中显示为1-11），如上图所示。 

有红色和蓝色两种颜色的棋子，对弈双方各执一种颜色的棋子。 

红方先手，由于Hex棋先手优势过大，所以强制规定红方第一手必须落在棋盘的(1,2)位置（在botzone 图形界面中显示为B3 位置）以限制先手优势。然后双方交替落子，每次只能落一个棋子，每个棋子占据一个六边形单元格；两个相邻的同色棋子被认为相互连通；最先将同色的两个边界用同色棋子连通的一方获胜（如上图即为蓝方胜）；对弈结果只有胜负，没有和棋。 

每步走棋限时1秒，内存限定256MB。任何非法操作会被立即判负，如程序崩溃、超时、坐标越界、格式错误等。 

## 算法思想

首先，当游戏开始时，程序需要读取用户的输入，来确定当前棋盘的初始状态。接着，程序会初始化一个名为moveList的列表，用于存储当前局面下所有可能的下一步棋步。同时，为了追踪已经走过的棋步，程序还会维护一个unmoveList列表。

然后，程序进入其核心部分——利用UCT算法建立蒙特卡洛树。蒙特卡洛树搜索是一种启发式搜索算法，它通过模拟对局来寻找最优决策。UCT算法结合了蒙特卡洛模拟和UCB（Upper Confidence Bound）选择策略。

在每一轮游戏中，程序都会执行一系列操作。首先，它会根据当前棋盘状态计算价值函数，这个函数能够评估每个位置的价值，为后续的决策提供依据。接着，程序利用蒙特卡洛树搜索算法来探索不同的棋局路径。在搜索过程中，程序会不断地进行决策，根据UCB选择策略选择下一个最有可能获胜的位置。

在选择落子点时，程序会考虑多种因素，包括当前局面下的胜率、对手的可能反应以及棋局的长期发展趋势。一旦选定一个落子点，程序就会更新棋盘状态，并将其添加到moveList中，以便在后续迭代中重复使用。

在搜索过程中，如果unmoveList不为空，程序会尝试扩展子节点，继续探索更多的棋局路径。通过不断地扩展和搜索，程序能够逐渐构建一个庞大的蒙特卡洛树，从而更准确地评估每个位置的价值和潜在风险。

除了搜索和决策外，程序还会利用反向传播技术来更新棋盘状态。当程序找到一个更优的落子点时，它会回溯到搜索树的根节点，并更新沿途节点的统计信息，以便在未来的搜索中能够更快地找到更好的决策。

最后，当搜索过程结束后，程序会根据UCB选择策略从moveList中选出一个最优的落子点，并判断当前局面下是否有胜者。如果没有胜者产生，程序会继续进行下一轮搜索和决策，直到游戏结束或达到预设的时间限制。
